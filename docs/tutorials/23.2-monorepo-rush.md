---
title: Monorepo
description: How to set up a monorepo with Piral and Rush.
audience: Architects, Developers
level: Proficient
section: Details
---

# Setting up a Monorepo with Piral and Rush

You might be wondering "what is this Rush"? Rush is a Node.js command line tool by Microsoft that allows you to manage monorepos. Classically, monorepos might be difficult to deal with as you might need to jump to different directories, patch multiple files at once, cannot really reference other packages in the monorepo, or have trouble with versioning of these packages. Rush helps you will of that - and more.

## Rush Setup

Before we get started, make sure you have the latest Rush release installed globally:
```sh
npm install -g @microsoft/rush
```

Let's start a new monorepo and add a Piral instance with some pilets. We begin with a new fresh directory:

```sh
git init
rush init
```

With these three commands we

1. initialize a new git repository,
2. generate rush's config files

At this point we should see four items in the directory:

1. *.git* (from the first command, the directory where git stores its information)
2. *rush.json* (from the second command, the file configuring Rush)
3. *.gitattributes* (from the second command, sets some git configurations)
4. *.gitignore* (from the second command, tells git which files to ignore)
5. *.travis.yml* (from the second command, configures the [Travice CI](https://www.travis-ci.com/) service)
6. *common* (from the second command, rush stores all files it needs in there. Read more about this in rush's [Config file reference](https://rushjs.io/pages/advanced/config_files/))

Great! Now we need to configure rush by opening rush.json and performing the following steps:
- **Choose a package manager:** Search for `npmVersion` inside the rush.json file. You'll see that rush uses pnpm as a default. Since i only tried this with npm we uncomment the `npmVersion` line and comment the `pnpmVersion` line. You should also see if you have the latest npm version installed globally and set this version here. You can of course feel free to use your preferred package manager. Read more about those [here](https://rushjs.io/pages/maintainer/package_managers/)
- **Custom npm registry:** If you use a custom npm registry you might configure it in `common\config\rush\.npmrc`. Read more about this [here](https://rushjs.io/pages/maintainer/npm_registry_auth/)
- **Folder structure:** Since i don't want to mix rush's files with my packages i add a folder "packages" in the root directory by running `mkdir tools`. All pilets and the app shell will live in their own folders directly inside the packages folder. In this scenario they are nested in a folder depth of 2 which is rush's default. If you want do have a different structure you might need to configure `projectFolderMinDepth` and `projectFolderMaxDepth` inside rush.json. I'll just uncomment them being set to 2.

## Add a piral instance
Now let's add a piral instance. Make a new directory *app-shell* (or whatever you want to call it - we'll refer to it as *app-shell* from here on) in the *packages* directory:

```sh
mkdir packages/app-shell
npx piral new --no-install --base packages/app-shell
```

Be sure it didn't install any dependencies. If it did just delete the `node_modules` folder and the `package-lock.json` file inside the app-shell folder. You need to delete those, because all node modules as well as the shrinkwrap file (in our case thats the package-lock.json file because we use npm) will be handled by rush inside the `common` folder. Rush will show an error if it does find a shrinkwrap file in any rush project.

To make rush aware of the app-shell project we need to add it to the `projects` setting inside the rush.json file like this:
```json
  "projects": [
    //...
    {
      "packageName": "app-shell",
      "projectFolder": "packages/app-shell"
    }
    //...
  ]
```
Here the `packageName` property value needs to match the actual name of your project defined inside `packages\app-shell\package.json`. `projectFolder` of course needs to point to the packages folder.

Now we are ready to install all project dependencies. Note that in a rush monorepo you shouldn't use any yarn or npm commands like `npm install`. Those commands would create a per project shrinkwrap file which rush doesn't want. instead rush has its own commands to handle things.

To install the dependencies of all packages inside our monorepo you can run `rush update` from any folder inside the monorepo. This will create node_modules folders in all package folders which will actually be just symlinks to `common\temp\node_modules`. If you want to remove all of them you can always run `rush purge` which is a very good command to do a clean start if you messed something up.

Now we can run `rush build` to build all packages inside the monorepo. This command assumes that every project has a build script and runs this script.

To run the app-shell locally cd into the app-shell folder and run `rushx start`. `rushx` is a way to run any of your scripts. So `rushx start` is basically the same as running `npm run start`. It's just shorter.

## Add a Pilet

When adding more items to the monorepo it may make sense to follow a certain naming convention. As an example, we could suffix the pilets with `-pilet`. The exact convention is up to you - we will refer to the `-pilet` for our convention in this tutorial. Just make sure to stay consistent.

The following command creates a new pilet called `foo-pilet`:

```sh
npx pilet new app-shell --no-install --base packages/foo-pilet
```

Like beforehand, go and delete the `node_modules` folder and the shrinkwrap file if those have been created.

To make rush aware of the foo-pilet we need to add it to the `projects` setting inside the rush.json file like this:
```json
  "projects": [
    //...
    {
      "packageName": "foo-pilet",
      "projectFolder": "packages/foo-pilet"
    }
    //...
  ]
```

Now we need to run `rush update` again to install the dependencies of the new pilet. Since we have a dependency on the `app-shell` inside of `packages\foo-pilet\package.json` rush will find `app-shell` inside the monorepo and will just symlinc the dependency to `packages\app-shell`.

You can now cd into `packages\foo-pilet` and run `rushx start` to run the pilet locally.

::: tip: If it does not work
In my case that did not work. I had to add `@babel/preset-env`, `@babel/preset-react` and `react` to the pilets devDependencies by running these 3 commands inside the pilets folder:
```sh
rush add -p @babel/preset-env --dev
rush add -p @babel/preset-react --dev
rush add -p react --dev
```
After adding new packages you sometimes need to run `rush purge` followed by `rush update --full` to really update all cache files.
:::

## Conclusion
As you can see rush is a handy tool to manage your monorepo. If you want to learn more about it go [here](https://rushjs.io) and read the rush's docs. They are really good. To setup a monorepo you should start [here](https://rushjs.io/pages/maintainer/setup_new_repo/) . If you are a developer using rush you might start [here](https://rushjs.io/pages/developer/new_developer/).
